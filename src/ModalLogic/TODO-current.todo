- risolvi le chiamate a modalStep in test

☐	TODO add enumAccReprAggr for relationAll, and for all worldtypes and relations
☐	TODO lancia con operatori hard

TODO Prova anche quel map(aggr->aggr...)

In scanner.jl rimuovi i gammas, rimuovi test_operators cambia il modo di indicare le features e featsnops
- Rimuovere anche enumAccRepr.

non-precompute_gammas, that is, allow training directly on Ontological Dataset


let split_consistency_check be an argument (split_consistency_satisfied_check) and create the debug and performance profiles

In tree.jl
_split!
- Also write test_condition this for OntologicalDataset and perform the step with that, and bring back check di nl per fare un cross check
- TODO add consistency_step_data and remove occurrences of "gamma"

Scrivi i apply_tree per MultiFrameOntologicalDataset e MultiFrameFeatModalDataset e verifica che funzioni tutto.

Verifica che il caching avvenga correttamente
Verifica caso split_threshold == false

Testa round_dataset_to_datatype/mapArrayToDataType in versione multiframe
Restore optimize_tree_parameters! optimizations



consistency checks down the dataset pipeline, modalDatasetIsConsistent_m,_g etc.
	DecisionTree.checkGammasConsistency da qualche parte (gammas[i], Xs[i], test_operators, relationSet)

Completa OntologicalDataset{T, N, WorldType} <: AbstractModalDataset{T, WorldType}
	ModalLogic.getInstanceAttribute(Xi, che usa tree.feature)

Create class for labeled datasets, and remove slice_mf_dataset.

rename modality<->relation, and i_frame

Valuta quanto è meglio usare accrepr_functions anzichè acc_functions

DONE:

initWorldSet(tree.initConditions, tree.worldTypes, channel_size(X)) : da risolvere ancora una volta tramite funzioni che inizializzano mondi per ciascuna istanza?

Fix useRelationAll e useRelationId. Probabilmente è meglio tenere useRelationAll.
DTree.initCondition->initConditions, DTree.worldType->worldTypes
Sf->Sfs, S->Ss
